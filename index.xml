<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>@cngthnh | tech for noobs</title>
        <link>https://cngthnh.github.io/</link>
        <description>Recent content on @cngthnh | tech for noobs</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>vi-vn</language>
        <lastBuildDate>Tue, 29 Dec 2020 18:23:11 +0700</lastBuildDate><atom:link href="https://cngthnh.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Web Scraping: Cào dữ liệu từ một trang web với BeautifulSoup 4 và Python</title>
        <link>https://cngthnh.github.io/p/web-scraping-cao-du-lieu-tu-mot-trang-web-voi-python/</link>
        <pubDate>Tue, 29 Dec 2020 18:23:11 +0700</pubDate>
        
        <guid>https://cngthnh.github.io/p/web-scraping-cao-du-lieu-tu-mot-trang-web-voi-python/</guid>
        <description>&lt;img src="https://cngthnh.github.io/p/web-scraping-cao-du-lieu-tu-mot-trang-web-voi-python/web-scraping.png" alt="Featured image of post Web Scraping: Cào dữ liệu từ một trang web với BeautifulSoup 4 và Python" /&gt;&lt;h2 id=&#34;scraping-là-gì&#34;&gt;Scraping là gì?&lt;/h2&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Scraping đơn giản là trích xuất thông tin từ một hệ thống, cơ sở dữ liệu hoặc trang web... nào đó. Khác với crawling, scraping không thu thập toàn bộ thông tin mà chỉ thu thập những thông tin phù hợp với mục đích của người lập trình. Trong quá trình scrap, chúng ta vừa cần thu thập dữ liệu, vừa trích xuất dữ liệu (data extraction) để loại bỏ các thành phần không cần thiết và chỉ để lại dữ liệu đã làm sạch phù hợp với mục đích.&lt;/p&gt;
&lt;h2 id=&#34;trước-khi-bắt-đầu-scrap&#34;&gt;Trước khi bắt đầu scrap&lt;/h2&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Chúng ta cần quan tâm trang web có bật cơ chế chặn bot hay không. Nếu có chúng ta cần có các biện pháp đối phó đối với từng cơ chế phát hiện:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quá nhiều request từ cùng một IP =&amp;gt; sử dụng các IP rotator cho mỗi request (Ex: StormProxies&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Phát hiện không hỗ trợ JS =&amp;gt; sử dụng các headless browser (trình duyệt không có giao diện người dùng) như Selenium, Puppeteer&amp;hellip;&lt;/li&gt;
&lt;li&gt;Cloudflare, sử dụng cookie, captcha để chặn bot: cái này mình chịu :&amp;lt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bắt-đầu-thôi&#34;&gt;Bắt đầu thôi&lt;/h2&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Để demo, mình sẽ scrap dữ liệu từ trang web tra cứu điểm thi của báo điện tử 24h. Có thể dùng các công cụ như Jupyter Notebook hoặc Google Colab để chạy demo này.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Trong demo này mình sẽ cần import các thư viện cần thiết là &lt;b&gt;pandas, requests, bs4, numpy&lt;/b&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; requests
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pandas
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bs4
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; numpy &lt;span style=&#34;color:#f92672&#34;&gt;as&lt;/span&gt; np
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p style=&#39;text-align: justify;&#39;&gt;Sử dụng công cụ DevTools của Chromium (nhấn nút F12). Nhận thấy thông tin ta cần scrap nằm ở tab 	&lt;b&gt;&amp;lt;tr&amp;gt;&lt;/b&gt; thứ 3, ta sẽ parse HTML ở tab này để lấy ra điểm ở các tab 	&lt;b&gt;&amp;lt;td&amp;gt;&lt;/b&gt;&lt;/p&gt;
&lt;div style=&#39;text-align: justify;&#39;&gt;&lt;img src=&#39;devtools-tr-tab.png&#39;/&gt;&lt;/div&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Ở đây mình sẽ ghi kết quả xuống file JSON để tiện dùng sau này. Thư viện pandas cho phép ghi dataframe xuống ở định dạng JSON hoặc CSV cực kì tiện lợi.&lt;/p&gt;
&lt;h5 id=&#34;source-code&#34;&gt;Source Code:&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://diemthi.24h.com.vn/?v_page=1&amp;amp;v_cum_thi=00&amp;amp;v_sbd=&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getPageContent&lt;/span&gt;(url, id):
  page &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;id)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bs4&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;BeautifulSoup(page&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;html.parser&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fieldCleaner&lt;/span&gt;(field):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(field)):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;(field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;(field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)):
            field&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(field)[j:]
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(field)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;(field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;(field[j]&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)):
            field&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(field)[:j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;(field)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeDup&lt;/span&gt;(field):
    field &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(field)
    j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len(field)):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (field[j]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;field[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]):
            field &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; field[:(j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;field[j:]
            j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;(field)

id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
birthday &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
math &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
literature &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
fLang &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
phys &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
chem &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
bio &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
his &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
geo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
civ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
note &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
khxh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
khtn &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
student_num&lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; sbd &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range (&lt;span style=&#34;color:#ae81ff&#34;&gt;1000001&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1100000&lt;/span&gt;):
    idstr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{0:08d}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(sbd)
    content &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getPageContent(url, idstr)
    tr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; content&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_all(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;tr&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (len(tr)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;): &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
    student_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; student_num&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    main &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bs4&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;BeautifulSoup(str(tr[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]),&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;html.parser&amp;#34;&lt;/span&gt;)
    mainFields &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; main&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_all(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)
    mainFields &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [bs4&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;BeautifulSoup(str(field), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;html.parser&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; field &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; mainFields]
    id&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text)
    id[student_num]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;fieldCleaner(id[student_num])
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      literature&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      literature&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      fLang&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      fLang&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      phys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      phys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      chem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      chem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      bio&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      bio&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    
    khtn_avg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(phys[student_num]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;chem[student_num]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;bio[student_num])&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
    khtn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{:.2f}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(khtn_avg)))
    
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      his&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      his&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      geo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      geo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mainFields[&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
      civ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(temp))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      civ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nan))
    
    khxh_avg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(his[student_num]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;geo[student_num]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;civ[student_num])&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
    khxh&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{:.2f}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(khxh_avg)))
    
df &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;DataFrame({&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;id&amp;#39;&lt;/span&gt;:id,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;math&amp;#39;&lt;/span&gt;:math,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;literature&amp;#39;&lt;/span&gt;:literature,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foreign lang&amp;#39;&lt;/span&gt;:fLang,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;history&amp;#39;&lt;/span&gt;:his,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;geo&amp;#39;&lt;/span&gt;:geo,   
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;civ&amp;#39;&lt;/span&gt;:civ,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SS-Mean&amp;#39;&lt;/span&gt;:khxh,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;phys&amp;#39;&lt;/span&gt;:phys,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;chem&amp;#39;&lt;/span&gt;:chem,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bio&amp;#39;&lt;/span&gt;:bio,
                  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NS-Mean&amp;#39;&lt;/span&gt;:khtn})
df&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_json(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data_points.json&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Lập trình Socket: Web Server đơn giản bằng C&#43;&#43;</title>
        <link>https://cngthnh.github.io/p/lap-trinh-socket-web-server-don-gian-cpp/</link>
        <pubDate>Mon, 28 Dec 2020 23:05:15 +0700</pubDate>
        
        <guid>https://cngthnh.github.io/p/lap-trinh-socket-web-server-don-gian-cpp/</guid>
        <description>&lt;img src="https://cngthnh.github.io/p/lap-trinh-socket-web-server-don-gian-cpp/nullSERVER.png" alt="Featured image of post Lập trình Socket: Web Server đơn giản bằng C&#43;&#43;" /&gt;&lt;h2 id=&#34;mô-hình-hoạt-động&#34;&gt;MÔ HÌNH HOẠT ĐỘNG&lt;/h2&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;&lt;img src=&#39;mo-hinh-hoat-dong-http.png&#39;&gt;&lt;/div&gt;
&lt;h5 id=&#34;về-phía-client&#34;&gt;Về phía Client&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Máy khách gửi một yêu cầu đến máy chủ một gói dữ liệu gồm phương thức mà
máy khách muốn yêu cầu đến máy chủ, URI (đường dẫn đến tài nguyên) và
phiên bản của giao thức HTTP. Tiếp theo đó là các headers (thông điệp
MIME) chứa các thông tin về yêu cầu của máy khách, thông tin về máy
khách…&lt;/p&gt;
&lt;h5 id=&#34;về-phía-server&#34;&gt;Về phía Server&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Máy chủ phản hồi với một dòng trạng thái, bao gồm phiên bản giao thức
HTTP, mã trạng thái (status code). Tiếp theo đó là các headers (thông
điệp MIME) chứa các thông tin về server và về nội dung dữ liệu trả về.
Cuối cùng là gửi trả lại cho máy khách nội dung mà máy khách yêu cầu
    (nếu tồn tại).&lt;/p&gt;
&lt;h3 id=&#34;định-tuyến&#34;&gt;Định tuyến&lt;/h3&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;&lt;img src=&#39;routing-overview.png&#39;&gt;&lt;/div&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Khi nhận được một yêu cầu từ máy khách, server sẽ xử lý yêu cầu để xác
định đường dẫn của tài nguyên mà máy khách muốn truy cập, kiểm tra tài
nguyên đó có tồn tại và được quyền truy cập hay không. Nếu tài nguyên
tồn tại và được quyền truy cập thì server sẽ trả về một gói tin phản hồi
bao gồm mã trạng thái kèm với nội dung tài nguyên. Nếu tài nguyên không
tồn tại hoặc không được quyền truy cập thì trả về trạng thái 404 (Not
    Found).&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Việc xác định và điều khiển hướng đi cho Response là nhiệm vụ của phần
định tuyến trong server. Các loại tài nguyên thông dụng được trả về
Content-Type theo MIME types. Tuy việc định tuyến được thực hiện tự động
dựa trên loại tài nguyên, nhưng cũng có một số ngoại lệ, ví dụ như khi
truy cập một đường dẫn, bộ phận định tuyến sẽ kiểm tra xem có tồn tại
file nào ở đường dẫn đã yêu cầu và có quyền truy cập hay không, nếu
không tìm thấy thì sẽ thử xem đường dẫn đó là một đường dẫn đến thư mục
và kiểm tra trong “thư mục” đó có tài nguyên HTML nào hay không, nếu có
thì sẽ hiển thị tài nguyên đó. Như vậy bộ phận định tuyến ưu tiên các
tài nguyên là file trước, nếu không tìm thấy thì sẽ thử xem đường dẫn đó
là một thư mục. Điều này sẽ giúp các truy cập có đường dẫn không rõ ràng
như “/” vẫn có thể truy cập bình thường vì lúc này server hiểu đường dẫn
    chính xác là “/index.html”.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Một ngoại lệ khác là điều hướng các truy cập từ “/files.html” hoặc
“/info.html” về “/index.html” nếu chưa đăng nhập (không có cookie hoặc
cookie không hợp lệ). Cùng với đó là điều hướng những truy cập từ
“/index.html” về “/info.html” nếu đã đăng nhập (đã đăng nhập thì không
    cần đăng nhập lại nên chuyển hướng về trang thông tin).&lt;/p&gt;
&lt;h3 id=&#34;xử-lý-thông-điệp&#34;&gt;Xử lý thông điệp&lt;/h3&gt;
&lt;h4 id=&#34;http-requests&#34;&gt;HTTP Requests&lt;/h4&gt;
&lt;h5 id=&#34;get-requests&#34;&gt;GET Requests&lt;/h5&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;&lt;img src=&#39;get-request.png&#39;&gt;&lt;/div&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Với các thông điệp yêu cầu, chúng ta cần xác định được phương thức,
đường dẫn và phiên bản HTTP. Tiếp đó là thông tin của các headers. Trong
khuôn khổ của đồ án này, chúng ta cần quan tâm nhất đến các headers:
If-Modified-Since và Cookie. Thực hiện cắt xâu để lấy các thuộc tính
    này.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Header &lt;b&gt;If-Modified-Since&lt;/b&gt; là cách để client truy vấn thông tin về sự
chỉnh sửa của file sau lần cuối cùng truy cập, client sẽ gửi nội dung
của header này là thời gian của lần truy cập cuối cùng. Nếu file đã được
chỉnh sửa sau ngày này, server sẽ trả về toàn bộ thông tin như bình
thường, nếu file chưa được chỉnh sửa thì máy chủ sẽ chỉ gửi về status
code 304 (Not Modified) và không gửi kèm nội dung file, như vậy sẽ tiết
kiệm được thời gian trao đổi dữ liệu, client sẽ lấy dữ liệu từ cache để
    hiển thị.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Header &lt;b&gt;Cookie&lt;/b&gt; được client dùng để thông báo cho server biết những
cookie (những tập tin được máy chủ gửi đến máy người dùng để ghi nhớ
những thông tin trạng thái, hoạt động của người dùng) nào đang được lưu
    tại client.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cookie: &amp;lt;cname1&amp;gt;=&amp;lt;cvalue1&amp;gt;; &amp;lt;cname2&amp;gt;=&amp;lt;cvalue2&amp;gt;;... 
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;post-requests&#34;&gt;POST Requests&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Tương tự với GET Requests, chúng ta cần đọc các thông tin liên quan.
Khác biệt ở chỗ phương thức POST sẽ gửi kèm một đoạn dữ liệu để máy chủ
xử lý thông tin. Đoạn dữ liệu này được ngăn cách với header bằng một xâu
    ngăn cách &lt;b&gt;\r\n&lt;/b&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST / HTTP/1.1\\r\\n

...\r\n

\r\n

&amp;lt;qname1&amp;gt;=&amp;lt;qvalue1&amp;gt;&amp;amp;&amp;lt;qname2&amp;gt;=&amp;lt;qvalue2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&#39;text-align: justify;&#39;&gt;Từ dữ liệu nhận được từ POST Request có thể lấy ra dữ liệu gồm các
trường cần thiết như: username, password, remember. Sau khi có được dữ
liệu của các trường trên thì so sánh để xem thông tin tài khoản có hợp
lệ hay không. Tên đăng nhập và mật khẩu mặc định là “admin” và “admin”,
nếu thông tin đăng nhập khác so với thông tin tài khoản mặc định thì sẽ
điều hướng đến 404.html hoặc khi đăng nhập thành công thì điều hướng tới
    info.html.&lt;/p&gt;
&lt;h4 id=&#34;http-responses&#34;&gt;HTTP Responses&lt;/h4&gt;
&lt;h5 id=&#34;status-code-200--ok&#34;&gt;Status Code 200 – OK&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Trả về khi yêu cầu của máy khách được máy chủ đáp ứng thành công. Dữ
liệu được yêu cầu sẽ trả về kèm theo HTTP Response.
    &lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Ta có thể gửi kèm header &lt;b&gt;Expires&lt;/b&gt; để quy định ngày hết hạn của tài
nguyên này, khi trôi qua ngày hết hạn, client sẽ buộc phải làm mới lại
    dữ liệu.&lt;/p&gt;
##### Status Code 303 – See Other
&lt;p style=&#39;text-align: justify;&#39;&gt;Trả về khi máy khách đăng nhập thành công vào trang web này, nó giúp
chuyển hướng đến trang thông tin là info.html bằng cách sử dụng phương
    thức GET.&lt;/p&gt;
&lt;h5 id=&#34;status-code-304--not-modified&#34;&gt;Status Code 304 – Not Modified&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Trả về khi máy khách đã truy cập trang web này trước đó, khi truy cập
    lại một lần nữa client sẽ gửi header truy vấn &lt;b&gt;If-Modified-Since&lt;/b&gt;, nếu
tài nguyên này chưa được chỉnh sửa sau lần truy cập gần nhất thì server
sẽ trả về status code 304 và không gửi kèm nội dung tài nguyên. Trình
    duyệt ở client sẽ hiển thị dữ liệu đã lưu ở cache&lt;/p&gt;
&lt;h5 id=&#34;status-code-404--not-found&#34;&gt;Status Code 404 – Not Found&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Trả về khi máy khách truy cập một tài nguyên không tồn tại, server trả
lời lại bằng status code 404 để thông báo rằng tài nguyên này không thể
    được đáp ứng.&lt;/p&gt;
&lt;h3 id=&#34;giao-tiếp-giữa-ui-và-server&#34;&gt;Giao tiếp giữa UI và server&lt;/h3&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Giao diện được thiết kế theo hướng tối giản để giúp người sử dụng dễ
tiếp cận, các thông tin quan trọng nằm ở vị trí dễ nhìn thấy. Riêng
trang download được xây dựng sẵn template cho các blocks và
đặt một block giữ chỗ trong tập tin HTML để server có thể nhận biết
vị trí chèn thông tin các blocks là danh sách các file hiện có trong thư
mục “download”. Khi xây dựng trang download theo hướng như thế thì khi
có tài nguyên mới được thêm vào thư mục download, người dùng sẽ không
cần phải thêm thông tin file thủ công vào file HTML mà việc đó đã được
thực hiện tự động nhờ bộ phận quét thông tin file và chèn nó vào trang
    download cho người dùng cuối.&lt;/p&gt;
&lt;h3 id=&#34;kiểu-truyền-tải&#34;&gt;Kiểu truyền tải&lt;/h3&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;&lt;b&gt;Transfer-Encoding&lt;/b&gt; header dùng để thông báo kiểu truyền tải với tài
    nguyên sắp được server trả lời. Với loại truyền tải &lt;b&gt;chunked&lt;/b&gt;, nội
dung của tài nguyên được chia thành các “bó” tin nhỏ, server sẽ thông
báo về kích thước của mỗi bó tin (ở hệ 16 – hexadecimal) trước khi gửi
nội dung của bó tin đó. Sau bó tin cuối cùng, server sẽ gửi kích thước
    bó tin kết thúc là 0byte sau đó kết thúc bằng &lt;b&gt;\r\n&lt;/b&gt;.
&lt;p style=&#39;text-align: justify;&#39;&gt;Kiểu truyền tải này được sử dụng trong chức năng download, các tài
nguyên trong trang download có kích thước lớn hơn hẳn các tài nguyên
HTML, CSS hay JS cần thiết để tải trang. Có thể tồn tại những tập tin
kích thước rất lớn đến vài trăm MB, vài GB hoặc thậm chí là TB. Để
truyền tải những nội dung có kích thước lớn như vậy, server không thể
đọc toàn bộ tài nguyên ấy để truyền cho máy khách, việc đó hao tốn
rất lớn chi phí vận hành của server. Để giải quyết vấn đề này thì
server sẽ thực hiện chia tài nguyên kích thước lớn thành các bó tin có
    kích thước nhỏ hơn để gửi cho máy khách theo kiểu truyền tải chunked.&lt;/p&gt;
&lt;h2 id=&#34;triển-khai-ứng-dụng&#34;&gt;TRIỂN KHAI ỨNG DỤNG&lt;/h2&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;&lt;img src=&#39;routing-diagram-nullSERVER.png&#39;&gt;&lt;/div&gt;
&lt;h3 id=&#34;định-tuyến-1&#34;&gt;Định tuyến&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Bộ phận định tuyến được triển khai theo sơ đồ như bên trên&lt;/em&gt;&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Bộ mã nguồn frontend của đồ án này được lưu trong thư mục &lt;b&gt;web-source&lt;/b&gt;
    nằm cùng đường dẫn với file thực thi của server&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Với các truy cập đến “files.html” và “info.html”, bộ phận định
tuyến sẽ kiểm tra xem có cookie nào được lưu ở máy khách và cookie đó có
hợp lệ hay không. Nếu hợp lệ (tức người dùng đã đăng nhập) thì cho phép
truy cập vào các tài nguyên này, nếu không thì chuyển hướng người dùng
về lại trang đăng nhập. Ngược lại, với các truy cập đến &#34;index.html”
và “/”, server cũng kiểm tra cookie, nếu đã đăng nhập rồi thì sẽ
chuyển hướng người dùng sang trang thông tin “info.html”. Với các tài
nguyên không nằm trong nhóm ngoại lệ bên trên, server sẽ kiểm tra xem
tài nguyên đó có tồn tại hay không, nếu không tồn tại thì thử tìm xem đó
có phải thư mục hay không, nếu là thư mục thì trả về file “index.html”
trong thư mục đó, nếu không có file “index.html” trong thư mục đó hoặc
đó không phải thư mục và tài nguyên đó cũng không tồn tại thì trả về mã
    lỗi 404 (Not Found) và trả về nội dung “404.html”.&lt;/p&gt;
### Xử lý đa luồng
&lt;p style=&#39;text-align: justify;&#39;&gt;Do mỗi trang web được yêu cầu không chỉ bao gồm 1 request mà bao gồm nhiều request đến tất cả các tài nguyên được nhúng vào trang web mà người dùng yêu cầu. Để đảm bảo tốc độ load trang, ta không thể chờ xử lý xong request này rồi mới xử lý tiếp các request khác. Hơn nữa, do tính chất của server phục vụ cho nhiều máy khách, không thể để một máy khách chờ được phục vụ trong khi đang đáp ứng cho máy khách khác. Chính vì những lý do này mà ta cần xử lý mỗi request ở một thread riêng độc lập với session chính.&lt;/p&gt;
&lt;h3 id=&#34;xây-dựng-giao-diện-cho-người-dùng-cuối&#34;&gt;Xây dựng giao diện cho người dùng cuối&lt;/h3&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Thư mục mã nguồn web-source bắt buộc phải nằm cùng đường dẫn với
    file thực thi để máy chủ có thể hoạt động chính xác&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Với ý tưởng về việc xây dựng một trang download tự động lấy các thông
tin file và hiển thị lên giao diện cho người dùng cuối như đã trình bày
trong mục Mô Hình Hoạt Động. Việc triển khai xây dựng giao diện dễ giao
    tiếp với máy chủ được thực hiện như sau:&lt;/p&gt;
**Block giữ chỗ:** *&amp;lt;//nullSERVER?FILES?//&amp;gt;*
&lt;p style=&#39;text-align: justify;&#39;&gt;Máy chủ sẽ tìm block giữ chỗ này, sau đó thay thế block này bằng các
    template đã được xây dựng sẵn như bên dưới.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;&lt;b&gt;Một block thông tin file khi được máy chủ chèn vào HTML có dạng như
    template sau:&lt;/b&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;content-box&amp;#34;&lt;/span&gt;&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;img&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file-icon&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;{đường&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dẫn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;đến&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;icon&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dựa&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;theo&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ext&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;}&lt;/span&gt;&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file-details&amp;#34;&lt;/span&gt;&amp;gt;
		&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;{đường&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dẫn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;đến&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;}&lt;/span&gt;&amp;gt; {tên file} &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
		&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;Size: {kích thước file} &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;
	&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p style=&#39;text-align: justify;&#39;&gt;Trong đó, những thuộc tính {màu xanh} được server tự động thay đổi tuỳ
theo từng tập tin. Với mỗi file được quét trong thư mục download, server
sẽ thêm một template bên trên và điền các thông tin của file vừa quét
vào, lặp lại công việc này với tất cả các file trong thư mục download ta
    sẽ có được danh sách những file có thể được người dùng cuối tải về.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Trang đăng nhập gửi về server 3 trường dữ liệu là &lt;b&gt;username&lt;/b&gt;,
    &lt;b&gt;password&lt;/b&gt; và &lt;b&gt;remember&lt;/b&gt; với phương thức POST. Các trường dữ
liệu trong form đăng nhập là các trường bắt buộc nhập, nếu không có nội
    dung được nhập thì không thể submit các nội dung này gửi đến máy chủ.&lt;/p&gt;
&lt;h3 id=&#34;truyền-tải-dữ-liệu&#34;&gt;Truyền tải dữ liệu&lt;/h3&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Transfer-Encoding: chunked được tận dụng tối đa thế mạnh nhờ bộ phận
chia tài nguyên cần truy cập thành các bó tin nhỏ, tránh đọc dữ liệu hết
    cả file trong 1 lần để tiết kiệm tài nguyên hệ thống.&lt;/p&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;Đối với các file HTML, CSS, JS được truy vấn để hiển thị cho người dùng
    cuối đều được truyền tải bằng phương thức thông thường (truyền cả file)&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;Xem source code trên &lt;a href=&#39;https://www.github.com/cngthnh&#39;&gt;&lt;b&gt;GitHub&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Thuật toán sắp xếp</title>
        <link>https://cngthnh.github.io/p/thuat-toan-sap-xep/</link>
        <pubDate>Sun, 27 Dec 2020 23:55:10 +0700</pubDate>
        
        <guid>https://cngthnh.github.io/p/thuat-toan-sap-xep/</guid>
        <description>&lt;img src="https://cngthnh.github.io/p/thuat-toan-sap-xep/sort.png" alt="Featured image of post Thuật toán sắp xếp" /&gt;&lt;h3 id=&#34;trình-bày-thuật-toán&#34;&gt;Trình bày thuật toán&lt;/h3&gt;
&lt;h4 id=&#34;selection-sort&#34;&gt;Selection Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Với trường hợp sắp xếp mảng tăng dần có &lt;b&gt;&lt;i&gt;n&lt;/i&gt;&lt;/b&gt; phần tử, thuật toán Selection Sort (sắp xếp chọn) chia mảng thành 2 mảng con đã sắp xếp và chưa sắp xếp. Sau đó, tìm phần tử nhỏ nhất của mảng con chưa sắp xếp và di chuyển phần tử đó về cuối mảng con đã sắp xếp. Ban đầu chưa có phần tử nào được sắp xếp, phần tử được chọn để so sánh là phần tử đầu tiên của mảng, so sánh phần tử đó với phần tử nhỏ nhất trong &lt;b&gt;&lt;i&gt;n-1&lt;/i&gt;&lt;/b&gt; phần tử còn lại, nếu phần tử được chọn lớn hơn phần tử nhỏ nhất của mảng con còn lại thì đổi chỗ 2 phần tử đó cho nhau. Tại mỗi vòng lặp, phần tử được chọn sẽ có vị trí tiến lên 1 đơn vị so với vòng lặp trước do sau mỗi vòng lặp sẽ có thêm 1 phần tử được di chuyển vào mảng con đã sắp xếp.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i; 
        &lt;span style=&#34;color:#75715e&#34;&gt;//phần tử thứ i là phần tử được chọn, phần tử này tạm thời là min
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; a[min]) min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j; 
        &lt;span style=&#34;color:#75715e&#34;&gt;//so sánh từng phần tử trong mảng con chưa sắp xếp với min hiện tại, nếu nhỏ hơn thì đó là min
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        swap(a[min], a[i]); &lt;span style=&#34;color:#75715e&#34;&gt;//đổi chỗ min và phần tử được chọn
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;selection-sort-example.png&#39; width=&#39;50%&#39; alt=&#39;Selection Sort&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Thay đổi của các phần tử trên mảng qua mỗi vòng lặp, phần tử có dấu * được đổi chỗ với phần tử đầu tiên trong mảng chưa sắp xếp (mảng màu xanh lá)
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; do không sử dụng mảng phụ&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;insertion-sort&#34;&gt;Insertion Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-1&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Thuật toán Insertion Sort (sắp xếp chèn) duyệt từng phần tử và chèn phần tử đó vào mảng con (là mảng từ phần tử đầu tiên đến phần tử phía trước phần tử đã chọn) đã sắp xếp sao cho mảng đã sắp xếp đó vẫn giữ nguyên tính chất tăng hoặc giảm.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-1&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;insertionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, j, key;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) 
    &lt;span style=&#34;color:#75715e&#34;&gt;//duyệt i từ 1 đến n, vì mảng con có 1 phần tử ở vị trí 0 luôn luôn đã được sắp xếp
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    {
        key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[i]; 
        &lt;span style=&#34;color:#75715e&#34;&gt;//chọn phần tử thứ i để chèn vào mảng con gồm các phần tử đứng trước i
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) 
        &lt;span style=&#34;color:#75715e&#34;&gt;//duyệt mảng con đứng trước i (mảng này đã sắp xếp tăng hoặc giảm)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; key) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;; 
            &lt;span style=&#34;color:#75715e&#34;&gt;//nếu a[j] &amp;lt;= key thì cần chèn key vào vị trí thứ j+1 để giữ nguyên tính chất của mảng con đứng trước i
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            a[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[j]; 
            &lt;span style=&#34;color:#75715e&#34;&gt;//nếu vẫn chưa tìm thấy vị trí cần chèn thì dời các phần tử lên 1 đơn vị để chừa chỗ chèn key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
        a[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key; chèn key vào vị trí j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;insertion_sort2.png&#39; width=&#39;50%&#39; alt=&#39;Insertion Sort&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Thay đổi của các phần tử trên mảng qua mỗi vòng lặp, các phần tử được di chuyển theo hướng mũi tên
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-1&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; - trong trường hợp mảng đã sắp xếp sẵn&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; do không sử dụng mảng phụ&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bubble-sort&#34;&gt;Bubble Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-2&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Thuật toán Bubble Sort (sắp xếp nổi bột) lặp lại công việc đổi chỗ 2 số kế nhau nếu chúng đang đứng sai thứ tự cho đến khi mảng được sắp xếp. Trong mỗi chu trình nổi bọt, giá trị lớn nhất (hoặc nhỏ nhất) trong mảng chưa sắp xếp sẽ dần dần “nổi” lên trên, nhập vào mảng đã sắp xếp.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-2&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Trong cài đặt Bubble Sort này, đã cải tiến bằng cách đặt 1 flag đánh dấu nếu không có sự hoán vị nào xảy ra (tức là mảng đã được sắp xếp và không cần chạy các vòng lặp còn lại nữa).
&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbleSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; isSwapped &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//flag đánh dấu mảng đã được sắp xếp hay chưa
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;//phần tử cuối cùng luôn nằm đúng vị trí
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        isSwapped &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#75715e&#34;&gt;//duyệt các phần tử chưa được sắp xếp và đẩy phần tử lớn nhất (hoặc nhỏ nhất) lên cuối dãy
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//duyệt j &amp;lt; n - i - 1 vì xét phần tử kế là j+1 = n - i =&amp;gt; không tràn sang mảng con đã sắp xếp ở cuối dãy
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
            {
                swap(a[j], a[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]);
                &lt;span style=&#34;color:#75715e&#34;&gt;//nếu 2 phần tử kế nhau nằm sai vị trí thì đổi chỗ
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                isSwapped &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isSwapped) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;//nếu đã sắp xếp thì dừng
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;bubble_sort.png&#39; width=&#39;80%&#39; alt=&#39;Bubble Sort&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Đổi chỗ 2 ô màu xanh lá qua mỗi bước, những ô màu xám đã được sắp xếp, ô màu trắng chưa được sắp xếp
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-2&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; - trong trường hợp mảng đã sắp xếp sẵn, vòng lặp chạy 1 lần rồi được gắn cờ đã sắp xếp và dừng hàm.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; do không sử dụng mảng phụ&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;merge-sort&#34;&gt;Merge Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-3&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Thuật toán Merge Sort (sắp xếp trộn) là một thuật toán chia để trị, thuật toán này sẽ chia mảng ra thành 2 mảng con, và tiếp tục công việc này với các mảng con đã chia cho tới khi nào những mảng con chỉ còn lại 1 phần tử, khi đó mỗi mảng con đều đã được sắp xếp do chỉ có 1 phần tử. Sau đó, thực hiện trộn các mảng con đã sắp xếp lại thành mảng con lớn hơn, lặp lại việc trộn mảng đến khi ta có mảng kết quả là toàn bộ các phần tử ban đầu đã được sắp xếp.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-3&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;/*đoạn này copy mảng con trái vào mảng L, mảng con phải vào mảng R; mảng con L có n1 phần tử, R có n2 phần tử*/&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;//thực hiện trộn 2 mảng L và R như sau: 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l; k &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; r; k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) a[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R[j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// nếu đã hết phần tử trong mảng L thì chỉ cho những phần tử của mảng R vào mảng kết quả
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; n2&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) a[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L[i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// nếu đã hết phần tử trong R thì cho những phần tử của L vào mảng kết quả 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; R[j]) a[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R[j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;//nếu L[i]&amp;gt;R[j] thì cho R[j] vào mảng kết quả
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; a[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L[i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;//còn lại thì cho L[i] vào mảng kết quả (nếu L[i]==R[j] thì cho L[i] vào mảng, L luôn nằm bên trái R nên đảm bảo tính ổn định)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; r)  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//phần tử giữa mảng
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    mergeSort(a, l, m); &lt;span style=&#34;color:#75715e&#34;&gt;//gọi đệ quy mảng con từ m trở về bên trái
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    mergeSort(a, m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, r); &lt;span style=&#34;color:#75715e&#34;&gt;//gọi đệ quy mảng con bên phải m
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    merge(a, l, m, r); &lt;span style=&#34;color:#75715e&#34;&gt;//gộp 2 mảng con
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;Merge-Sort-Algorithm.png&#39; alt=&#39;Merge Sort&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Màu tím là quá trình chia mảng thành các mảng con, màu xanh là quá trình trộn mảng, chia đến khi thành các mảng chỉ có 1 phần tử sau đó trộn các mảng đó lại
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-3&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; do phải sử dụng các mảng con tạm để lưu giá trị trước khi trộn chúng thành mảng kết quả&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-4&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Thuật toán Quick Sort là một thuật toán chia để trị với mấu chốt là thuật toán phân hoạch, chọn một phần tử trên mảng làm phần tử đánh dấu (pivot), sau đó di chuyển tất cả các phần tử nhỏ hơn pivot sang bên trái và các phần tử lớn hơn pivot sang bên phải. Lặp lại việc này với mỗi phân đoạn đã chia ta sẽ có được mảng đã sắp xếp
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-4&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Trong cài đặt này, sử dụng pivot ngẫu nhiên sẽ tránh được trường hợp xấu với mảng sắp xếp ngược
&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;quickSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r)
{
    srand(time(NULL)); 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rand() &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l, j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; j) &lt;span style=&#34;color:#75715e&#34;&gt;//nếu đã duyệt hết mảng thì dừng vòng lặp
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (a[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; key) i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//tìm phần tử bên trái lớn hơn pivot
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (a[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; key) j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//tìm phần tử bên phải nhỏ hơn pivot
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; j)
        {
            &lt;span style=&#34;color:#75715e&#34;&gt;//nếu i vẫn nằm bên trái pivot và j vẫn nằm bên phải pivot và phần tử a[i]&amp;gt;a[j] thì đổi chỗ 2 phần tử này
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j) swap(a[i], a[j]);
            &lt;span style=&#34;color:#75715e&#34;&gt;//đã xử lý xong 2 phần tử này, tăng i, giảm j để sang phần tử khác
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
            j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;//nếu l&amp;lt;j tức là mảng con bên trái còn nhiều hơn 1 phần tử, tiếp tục lặp lại thao tác cho mảng con bên trái
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j) quickSort(a, l, j);
    &lt;span style=&#34;color:#75715e&#34;&gt;//nếu i&amp;lt;r tức là mảng con bên phải còn nhiều hơn 1 phần tử, tiếp tục lặp lại thao tác cho mảng con bên phải
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; r) quickSort(a, i, r); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;quicksort.png&#39; alt=&#39;Quick Sort&#39; width=&#39;80%&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Các phần tử khác màu tím là các phần tử được chọn làm pivot trong mỗi phân đoạn, các phân tử màu tím nhỏ hơn sẽ được di chuyển về bên trái pivot, lớn hơn sẽ di chuyển về bên phải pivot
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-4&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt; - trong trường hợp pivot luôn bị random trúng phần tử lớn nhất (hoặc bé nhất)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt; trong trường hợp trung bình và &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; trong trường hợp pivot luôn bị random trúng phần tử lớn nhất (hoặc bé nhất) khiến việc phân hoạch bị lệch thành 1 mảng con có &lt;em&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/em&gt; phần tử và mảng con còn lại có &lt;em&gt;&lt;strong&gt;n-1&lt;/strong&gt;&lt;/em&gt; phần tử =&amp;gt; sử dụng &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt; callstack&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heap-sort&#34;&gt;Heap Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-5&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Heap Sort có thể được xem là phiên bản cải tiến của Selection Sort với cơ chế tìm phần tử lớn nhất (hoặc nhỏ nhất) của mảng con chưa sắp xếp và di chuyển vào mảng con đã sắp xếp. Khác biệt nằm ở chỗ Heap Sort sử dụng cấu trúc heap để tìm phần tử lớn nhất (hoặc nhỏ nhất) thay vì tìm kiếm tuyến tính. Cấu trúc heap có thể biểu diễn ở dạng cây nhị phân cân bằng như bên dưới để dễ hình dung cách hoạt động của thuật toán này.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-5&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;heapify&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;//giá trị lớn nhất là giá trị tại nút đang xét
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; largest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//vị trí nút con bên trái
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//vị trí nút con bên phải
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//nếu nút con bên trái lớn hơn nút đang xét thì gán nút con trái là lớn nhất
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a[l] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a[largest]) largest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l;
    &lt;span style=&#34;color:#75715e&#34;&gt;//nếu nút con bên phải lớn hơn nút đang xét thì gán nút con phải là lớn nhất
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (r &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a[r] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a[largest]) largest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (largest &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; i) 
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;//nếu giá trị lớn nhất không phải là nút cha thì hoán đổi giá trị nút cha và nút con lớn nhất để nút cha trở thành lớn nhất và đệ quy với nút con vừa đổi giá trị để đảm bảo nút cha luôn lớn hơn nút con trên toàn bộ cây
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        swap(a[i], a[largest]);
        heapify(a, n, largest);
    }
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;heapSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;//thực hiện tái cấu trúc mảng ban đầu thành heap (nút cha luôn lớn hơn nút con)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//các nút lớn hơn n/2-1 là các nút lá nên không cần xây dựng heap
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) heapify(a, n, i);
    &lt;span style=&#34;color:#75715e&#34;&gt;//vì nút cha là nút lớn nhất nên ta sẽ đổi giá trị ở nút cha và nút lá cuối cùng bên phải và ngắt nút lá đó ra khỏi cây
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//nút lá đó chính là phần tử đã được sắp xếp
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;)
    {
        swap(a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], a[i]);
        heapify(a, i, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;//thực hiện build heap lại với nút cha mới
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;heap_sort.png&#39; width=&#39;80%&#39; alt=&#39;Heap Sort&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	[Xây dựng heap - Đổi chỗ nút cha và nút lá cuối cùng bên phải - Ngắt nút lá] và lặp lại thao tác này cho tới khi nào mảng chỉ còn duy nhất một phần tử. Phần tử màu xanh lá cây trong hình trên là phần tử đã được sắp xếp
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-5&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian: Chiều cao của cây là &lt;em&gt;&lt;strong&gt;nlog&lt;sub&gt;2&lt;/sub&gt;n&lt;/strong&gt;&lt;/em&gt; và mất &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt; lần duyệt cây để có được mảng đã sắp xếp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; (không sử dụng mảng phụ)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;binary-insertion-sort&#34;&gt;Binary Insertion Sort&lt;/h4&gt;
&lt;h5 id=&#34;ý-tưởng-6&#34;&gt;Ý tưởng&lt;/h5&gt;
&lt;p style=&#39;text-align: justify;&#39;&gt;
    Binary Insertion Sort là phiên bản cải tiến của Insertion Sort, nó dùng thuật toán tìm kiếm nhị phân (chặt nhị phân - Binary Search) để tìm vị trí chèn phần tử ở mảng con chưa sắp xếp vào mảng con đã sắp xếp sao cho vẫn giữ nguyên tính chất tăng hoặc giảm.
&lt;/p&gt;
&lt;h5 id=&#34;minh-hoạ-thuật-toán-6&#34;&gt;Minh hoạ thuật toán&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;binarySearch&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; selected)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; r)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[m] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; selected) 
        {
            &lt;span style=&#34;color:#75715e&#34;&gt;//nếu có nhiều phần tử trùng nhau thì chèn vào sau phần tử trùng cuối cùng =&amp;gt; Đảm bảo tính ổn định
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (a[&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;m] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; selected);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (m &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; r) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; m;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[m] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; selected) l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//nếu a[m] nhỏ hơn phần tử đã chọn thì vị trí chèn nằm bên phải m
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//ngược lại thì vị trí chèn nằm bên trái m
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#75715e&#34;&gt;//nếu không có phần tử nào trong mảng con đã sắp xếp bằng với phần tử đã chọn thì xét tại a[l], nếu a[l] lớn hơn thì chèn vào trước a[l]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a[l] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; selected) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l;
    &lt;span style=&#34;color:#75715e&#34;&gt;//ngược lại thì chèn vào sau a[l]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;binaryInsertionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; selected &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[i];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; binarySearch(a, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, j, selected);
        &lt;span style=&#34;color:#75715e&#34;&gt;//dời các phần tử sau vị trí đã tìm sang bên phải 1 đơn vị để chừa chỗ chèn giá trị
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; found)
        {
            a[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[j];
            j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;//chèn vào vị trí đã tìm
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        a[found] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; selected;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p style=&#39;text-align: center;&#39;&gt;
    Hình ảnh trực quan minh hoạ cho sự dịch chuyển của các phần tử trong mảng tương tự như Hình 2 (phần Insertion Sort)
&lt;/p&gt;
&lt;h5 id=&#34;đánh-giá-thuật-toán-6&#34;&gt;Đánh giá thuật toán&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Độ phức tạp thời gian:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xấu nhất: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trung bình: &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tốt nhất: &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt; - trong trường hợp mảng đã sắp xếp sẵn, mất &lt;em&gt;&lt;strong&gt;log&lt;sub&gt;2&lt;/sub&gt;n&lt;/strong&gt;&lt;/em&gt; lần chặt nhị phân và &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt; vòng lặp duyệt mảng&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bộ nhớ sử dụng: &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; (không sử dụng mảng phụ)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;thực-nghiệm&#34;&gt;Thực nghiệm&lt;/h3&gt;
&lt;h4 id=&#34;dữ-liệu-có-thứ-tự-ngẫu-nhiên&#34;&gt;Dữ liệu có thứ tự ngẫu nhiên&lt;/h4&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;randomized.png&#39; alt=&#39;Biểu đồ so sánh thời gian với dữ liệu ngẫu nhiên&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu thứ tự ngẫu nhiên
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;nhận-xét&#34;&gt;Nhận xét&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Các thuật toán Merge Sort, Quick Sort, Heap Sort đều chạy rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất), trong đó Quick Sort nhanh hơn ở hầu hết các bài test.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thuật toán Bubble Sort có thời gian chạy lâu nhất, gấp nhiều lần các thuật toán khác. Bubble Sort chậm hơn tất cả các thuật toán khác trong nhóm thuật toán sắp xếp chậm mặc dù được đánh giá cùng với độ phức tạp thời gian &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt; do phải thực hiện phép hoán vị và duyệt lại mảng quá nhiều lần (dù đã cải tiến bằng cách thoát vòng lặp duyệt mảng nếu phát hiện mảng đã sắp xếp).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insertion Sort và Binary Insertion Sort mất thời gian dưới 50s ở bài test có dữ liệu lớn nhất, trong đó Binary Insertion Sort nhanh hơn Insertion Sort khoảng 30% do cải tiến việc tìm vị trí bằng chặt nhị phân.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dữ-liệu-đã-được-sắp-xếp&#34;&gt;Dữ liệu đã được sắp xếp&lt;/h4&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;sorted.png&#39; alt=&#39;Biểu đồ so sánh thời gian với dữ liệu đã sắp xếp&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu đã được sắp xếp
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;nhận-xét-1&#34;&gt;Nhận xét&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tất cả các thuật toán đều chạy rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất) với mảng đã được sắp xếp sẵn, trừ Selection Sort do cách tìm kiếm phần tử nhỏ nhất theo phương pháp tìm kiếm tuần tự nên phải duyệt lại mảng rất nhiều lần.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insertion Sort chạy nhanh hơn hẳn so với khi sắp xếp mảng ngẫu nhiên do việc tìm vị trí bắt đầu từ ngay trước điểm đã chọn để chèn và vị trí cần chèn chính là chỗ cũ nên thời gian tìm vị trí và dời các phần tử là &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt;, cộng thêm duyệt mảng mất &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; nên tổng độ phức tạp thời gian của Insertion Sort ở bài test này chỉ là &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Binary Insertion Sort ở bài test này chậm hơn so với Insertion Sort một chút, do phương pháp chặt nhị phân nên thời gian tìm kiếm vị trí mất &lt;em&gt;&lt;strong&gt;O(log&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt; thay vì &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt;, thời gian dời các phần tử là &lt;em&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/em&gt; do vị trí chèn chính là chỗ cũ, vậy nên tổng độ phức tạp thời gian của Binary Insertion Sort ở bài test này là &lt;em&gt;&lt;strong&gt;O(nlog&lt;sub&gt;2&lt;/sub&gt;n)&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bubble Sort chạy nhanh hơn hẳn so với mảng ngẫu nhiên do đã cải tiến, nếu duyệt qua mảng mà không có bất kì phép hoán vị nào tức là mảng đã sắp xếp và không cần sắp xếp nữa, ở bài test này độ phức tạp là &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Các thuật toán Quick Sort, Merge Sort, Heap Sort vẫn rất nhanh, chênh lệch không lớn so với mảng ngẫu nhiên.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dữ-liệu-đã-sắp-xếp-ngược&#34;&gt;Dữ liệu đã sắp xếp ngược&lt;/h4&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;reversed.png&#39; alt=&#39;Biểu đồ so sánh thời gian với dữ liệu đã sắp xếp ngược&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu đã sắp xếp ngược
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;nhận-xét-2&#34;&gt;Nhận xét&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bubble Sort thể hiện rất tệ ở mảng sắp xếp ngược, do phải thực hiện &lt;em&gt;&lt;strong&gt;O(n)&lt;/strong&gt;&lt;/em&gt; phép hoán vị mới có thể làm phần tử lớn nhất “nổi bọt” đến cuối mảng&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insertion Sort và Binary Insertion Sort sắp xếp lâu gấp đôi so với mảng ngẫu nhiên, do với mỗi lần chèn phần tử đều phải dời toàn bộ mảng con đã sắp xếp để chèn phần tử vào (do mảng xếp ngược có phần tử đứng sau luôn bé hơn phần tử đứng trước). Binary Insertion Sort vẫn nhanh hơn Insertion Sort khoảng 30%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selection Sort có thời gian chạy không thay đổi quá nhiều so với mảng ngẫu nhiên và mảng đã sắp xếp, do thuật toán này luôn phải duyệt lại mảng nhiều lần để tìm kiếm tuần tự phần tử min trong mảng chưa sắp xếp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Merge Sort, Quick Sort và Heap Sort vẫn rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất) và không chênh lệch nhau nhiều, Quick Sort nhanh hơn một chút so với hai thuật toán còn lại&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dữ-liệu-gần-như-đã-sắp-xếp&#34;&gt;Dữ liệu gần như đã sắp xếp&lt;/h4&gt;
&lt;div style=&#39;text-align: center;&#39;&gt;
    &lt;img src=&#39;nearlysorted.png&#39; alt=&#39;Biểu đồ so sánh thời gian với dữ liệu gần như đã sắp xếp&#39;&gt;&lt;br&gt;
    &lt;p&gt;
	Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu gần như đã sắp xếp
    &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&#34;nhận-xét-3&#34;&gt;Nhận xét&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Selection Sort vẫn giữ thời gian chạy giống như các mảng với thứ tự sắp xếp ngẫu nhiên, đã sắp xếp và sắp xếp ngược do tính chất của thuật toán.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bubble Sort với mảng gần như sắp xếp chạy nhanh hơn Selection Sort và nhanh hơn khi sắp xếp các mảng ngẫu nhiên và sắp xếp ngược do chỉ có một vài phần tử bị xáo trộn, nên chỉ phải duyệt lại mảng &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; lần (với &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; là số phần tử nằm sai vị trí) và số lần hoán vị với mỗi vòng lặp nhỏ hơn hoặc bằng &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt; (tuỳ thuộc vị trí của phần tử bị xáo trộn).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Các thuật toán còn lại đều sắp xếp rất nhanh (dưới 0.3s với bài test có dữ liệu lớn nhất). Trong đó Insertion Sort và Binary Insertion Sort là nhanh nhất do chỉ phải chèn &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; phần tử bị xáo trộn vào mảng đã sắp xếp.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Merge Sort, Quick Sort, Heap Sort sắp xếp mảng gần như đã sắp xếp với thời gian gần như tương tự các sắp xếp mảng khác.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;đánh-giá-tổng-quan&#34;&gt;Đánh giá tổng quan&lt;/h4&gt;
&lt;h5 id=&#34;đánh-giá&#34;&gt;Đánh giá&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Thuật toán Quick Sort nhanh hơn ở hầu hết các trường hợp (trừ mảng đã sắp xếp do đây là trường hợp đặc biệt của Bubble Sort, Insertion Sort và Binary Insertion Sort nên các thuật toán này chạy nhanh hơn).&lt;/li&gt;
&lt;li&gt;Bubble Sort chậm nhất ở hầu hết các trường hợp (trừ trường hợp mảng đã sắp xếp).&lt;/li&gt;
&lt;li&gt;Insertion Sort, Binary Insertion Sort, Bubble Sort sắp xếp chậm ở các mảng ngẫu nhiên, mảng xếp ngược. Nhưng lại nhanh hơn rõ rệt ở mảng đã sắp xếp hoặc gần như sắp xếp.&lt;/li&gt;
&lt;li&gt;Heap Sort và Merge Sort chậm hơn Quick Sort một chút nhưng lại ổn định về thời gian hơn QuickSort (không có trường hợp xấu &lt;em&gt;&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Merge Sort có nhược điểm là tốn bộ nhớ tạm để chứa các mảng con cần trộn.&lt;/li&gt;
&lt;li&gt;Selection Sort chậm đều nhau ở tất cả các thứ tự mảng do phải duyệt toàn bộ mảng con chưa sắp xếp để tìm phần tử nhỏ nhất, không có khác biệt trong tất cả các thứ tự mảng test.&lt;/li&gt;
&lt;li&gt;Tuỳ vào cách chọn pivot quyết định QuickSort nhanh hay chậm, ở đây sử dụng Randomized QuickSort nên không bị trường hợp xấu ở thứ tự mảng xếp ngược giống như khi chọn pivot ở cuối mảng.&lt;/li&gt;
&lt;li&gt;Các thuật toán Bubble Sort, Insertion Sort, Selection Sort, Binary Insertion Sort hiệu suất thấp nhưng cài đặt dễ dàng hơn so với Merge Sort, Quick Sort và Heap Sort.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;phân-nhóm-thuật-toán-theo-độ-ổn-định&#34;&gt;Phân nhóm thuật toán theo độ ổn định&lt;/h5&gt;
&lt;h6 id=&#34;nhóm-thuật-toán-sắp-xếp-ổn-định-cần-cài-đặt-cẩn-thận-để-đảm-bảo-tính-ổn-định---chi-tiết-trong-phần-mô-tả-thuật-toán&#34;&gt;Nhóm thuật toán sắp xếp ổn định (cần cài đặt cẩn thận để đảm bảo tính ổn định - chi tiết trong phần mô tả thuật toán)&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Merge Sort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Binary Insertion Sort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insertion Sort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bubble Sort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selection Sort&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;nhóm-thuật-toán-sắp-xếp-không-ổn-định&#34;&gt;Nhóm thuật toán sắp xếp không ổn định&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Heap Sort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quick Sort&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
