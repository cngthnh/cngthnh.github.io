[{"content":"MÔ HÌNH HOẠT ĐỘNG  Về phía Client Máy khách gửi một yêu cầu đến máy chủ một gói dữ liệu gồm phương thức mà máy khách muốn yêu cầu đến máy chủ, URI (đường dẫn đến tài nguyên) và phiên bản của giao thức HTTP. Tiếp theo đó là các headers (thông điệp MIME) chứa các thông tin về yêu cầu của máy khách, thông tin về máy khách…\nVề phía Server Máy chủ phản hồi với một dòng trạng thái, bao gồm phiên bản giao thức HTTP, mã trạng thái (status code). Tiếp theo đó là các headers (thông điệp MIME) chứa các thông tin về server và về nội dung dữ liệu trả về. Cuối cùng là gửi trả lại cho máy khách nội dung mà máy khách yêu cầu (nếu tồn tại).\nĐịnh tuyến  Khi nhận được một yêu cầu từ máy khách, server sẽ xử lý yêu cầu để xác định đường dẫn của tài nguyên mà máy khách muốn truy cập, kiểm tra tài nguyên đó có tồn tại và được quyền truy cập hay không. Nếu tài nguyên tồn tại và được quyền truy cập thì server sẽ trả về một gói tin phản hồi bao gồm mã trạng thái kèm với nội dung tài nguyên. Nếu tài nguyên không tồn tại hoặc không được quyền truy cập thì trả về trạng thái 404 (Not Found).\nViệc xác định và điều khiển hướng đi cho Response là nhiệm vụ của phần định tuyến trong server. Các loại tài nguyên thông dụng được trả về Content-Type theo MIME types. Tuy việc định tuyến được thực hiện tự động dựa trên loại tài nguyên, nhưng cũng có một số ngoại lệ, ví dụ như khi truy cập một đường dẫn, bộ phận định tuyến sẽ kiểm tra xem có tồn tại file nào ở đường dẫn đã yêu cầu và có quyền truy cập hay không, nếu không tìm thấy thì sẽ thử xem đường dẫn đó là một đường dẫn đến thư mục và kiểm tra trong “thư mục” đó có tài nguyên HTML nào hay không, nếu có thì sẽ hiển thị tài nguyên đó. Như vậy bộ phận định tuyến ưu tiên các tài nguyên là file trước, nếu không tìm thấy thì sẽ thử xem đường dẫn đó là một thư mục. Điều này sẽ giúp các truy cập có đường dẫn không rõ ràng như “/” vẫn có thể truy cập bình thường vì lúc này server hiểu đường dẫn chính xác là “/index.html”.\nMột ngoại lệ khác là điều hướng các truy cập từ “/files.html” hoặc “/info.html” về “/index.html” nếu chưa đăng nhập (không có cookie hoặc cookie không hợp lệ). Cùng với đó là điều hướng những truy cập từ “/index.html” về “/info.html” nếu đã đăng nhập (đã đăng nhập thì không cần đăng nhập lại nên chuyển hướng về trang thông tin).\nXử lý thông điệp HTTP Requests GET Requests  Với các thông điệp yêu cầu, chúng ta cần xác định được phương thức, đường dẫn và phiên bản HTTP. Tiếp đó là thông tin của các headers. Trong khuôn khổ của đồ án này, chúng ta cần quan tâm nhất đến các headers: If-Modified-Since và Cookie. Thực hiện cắt xâu để lấy các thuộc tính này.\nHeader If-Modified-Since là cách để client truy vấn thông tin về sự chỉnh sửa của file sau lần cuối cùng truy cập, client sẽ gửi nội dung của header này là thời gian của lần truy cập cuối cùng. Nếu file đã được chỉnh sửa sau ngày này, server sẽ trả về toàn bộ thông tin như bình thường, nếu file chưa được chỉnh sửa thì máy chủ sẽ chỉ gửi về status code 304 (Not Modified) và không gửi kèm nội dung file, như vậy sẽ tiết kiệm được thời gian trao đổi dữ liệu, client sẽ lấy dữ liệu từ cache để hiển thị.\nHeader Cookie được client dùng để thông báo cho server biết những cookie (những tập tin được máy chủ gửi đến máy người dùng để ghi nhớ những thông tin trạng thái, hoạt động của người dùng) nào đang được lưu tại client.\nCookie: \u0026lt;cname1\u0026gt;=\u0026lt;cvalue1\u0026gt;; \u0026lt;cname2\u0026gt;=\u0026lt;cvalue2\u0026gt;;... POST Requests Tương tự với GET Requests, chúng ta cần đọc các thông tin liên quan. Khác biệt ở chỗ phương thức POST sẽ gửi kèm một đoạn dữ liệu để máy chủ xử lý thông tin. Đoạn dữ liệu này được ngăn cách với header bằng một xâu ngăn cách \\r\\n.\nPOST / HTTP/1.1\\\\r\\\\n ...\\r\\n \\r\\n \u0026lt;qname1\u0026gt;=\u0026lt;qvalue1\u0026gt;\u0026amp;\u0026lt;qname2\u0026gt;=\u0026lt;qvalue2\u0026gt; Từ dữ liệu nhận được từ POST Request có thể lấy ra dữ liệu gồm các trường cần thiết như: username, password, remember. Sau khi có được dữ liệu của các trường trên thì so sánh để xem thông tin tài khoản có hợp lệ hay không. Tên đăng nhập và mật khẩu mặc định là “admin” và “admin”, nếu thông tin đăng nhập khác so với thông tin tài khoản mặc định thì sẽ điều hướng đến 404.html hoặc khi đăng nhập thành công thì điều hướng tới info.html.\nHTTP Responses Status Code 200 – OK Trả về khi yêu cầu của máy khách được máy chủ đáp ứng thành công. Dữ liệu được yêu cầu sẽ trả về kèm theo HTTP Response. Ta có thể gửi kèm header **Expires** để quy định ngày hết hạn của tài nguyên này, khi trôi qua ngày hết hạn, client sẽ buộc phải làm mới lại dữ liệu.\nStatus Code 303 – See Other Trả về khi máy khách đăng nhập thành công vào trang web này, nó giúp chuyển hướng đến trang thông tin là info.html bằng cách sử dụng phương thức GET.\nStatus Code 304 – Not Modified Trả về khi máy khách đã truy cập trang web này trước đó, khi truy cập lại một lần nữa client sẽ gửi header truy vấn If-Modified-Since, nếu tài nguyên này chưa được chỉnh sửa sau lần truy cập gần nhất thì server sẽ trả về status code 304 và không gửi kèm nội dung tài nguyên. Trình duyệt ở client sẽ hiển thị dữ liệu đã lưu ở cache\nStatus Code 404 – Not Found Trả về khi máy khách truy cập một tài nguyên không tồn tại, server trả lời lại bằng status code 404 để thông báo rằng tài nguyên này không thể được đáp ứng.\nGiao tiếp giữa UI và server Giao diện được thiết kế theo hướng tối giản để giúp người sử dụng dễ tiếp cận, các thông tin quan trọng nằm ở vị trí dễ nhìn thấy. Riêng trang download được xây dựng sẵn template cho các blocks và đặt một block giữ chỗ trong tập tin HTML để server có thể nhận biết vị trí chèn thông tin các blocks là danh sách các file hiện có trong thư mục “download”. Khi xây dựng trang download theo hướng như thế thì khi có tài nguyên mới được thêm vào thư mục download, người dùng sẽ không cần phải thêm thông tin file thủ công vào file HTML mà việc đó đã được thực hiện tự động nhờ bộ phận quét thông tin file và chèn nó vào trang download cho người dùng cuối.\nKiểu truyền tải Transfer-Encoding header dùng để thông báo kiểu truyền tải với tài nguyên sắp được server trả lời. Với loại truyền tải chunked, nội dung của tài nguyên được chia thành các “bó” tin nhỏ, server sẽ thông báo về kích thước của mỗi bó tin (ở hệ 16 – hexadecimal) trước khi gửi nội dung của bó tin đó. Sau bó tin cuối cùng, server sẽ gửi kích thước bó tin kết thúc là 0byte sau đó kết thúc bằng \\r\\n. Kiểu truyền tải này được sử dụng trong chức năng download, các tài nguyên trong trang download có kích thước lớn hơn hẳn các tài nguyên HTML, CSS hay JS cần thiết để tải trang. Có thể tồn tại những tập tin kích thước rất lớn đến vài trăm MB, vài GB hoặc thậm chí là TB. Để truyền tải những nội dung có kích thước lớn như vậy, server không thể đọc toàn bộ tài nguyên ấy để truyền cho máy khách, việc đó hao tốn rất lớn chi phí vận hành của server. Để giải quyết vấn đề này thì server sẽ thực hiện chia tài nguyên kích thước lớn thành các bó tin có kích thước nhỏ hơn để gửi cho máy khách theo kiểu truyền tải chunked.\nTRIỂN KHAI ỨNG DỤNG  Định tuyến Bộ phận định tuyến được triển khai theo sơ đồ như bên trên\nBộ mã nguồn frontend của đồ án này được lưu trong thư mục web-source nằm cùng đường dẫn với file thực thi của server\nVới các truy cập đến “files.html” và “info.html”, bộ phận định tuyến sẽ kiểm tra xem có cookie nào được lưu ở máy khách và cookie đó có hợp lệ hay không. Nếu hợp lệ (tức người dùng đã đăng nhập) thì cho phép truy cập vào các tài nguyên này, nếu không thì chuyển hướng người dùng về lại trang đăng nhập. Ngược lại, với các truy cập đến \"index.html” và “/”, server cũng kiểm tra cookie, nếu đã đăng nhập rồi thì sẽ chuyển hướng người dùng sang trang thông tin “info.html”. Với các tài nguyên không nằm trong nhóm ngoại lệ bên trên, server sẽ kiểm tra xem tài nguyên đó có tồn tại hay không, nếu không tồn tại thì thử tìm xem đó có phải thư mục hay không, nếu là thư mục thì trả về file “index.html” trong thư mục đó, nếu không có file “index.html” trong thư mục đó hoặc đó không phải thư mục và tài nguyên đó cũng không tồn tại thì trả về mã lỗi 404 (Not Found) và trả về nội dung “404.html”.\nXây dựng giao diện cho người dùng cuối Thư mục mã nguồn web-source bắt buộc phải nằm cùng đường dẫn với file thực thi để máy chủ có thể hoạt động chính xác\nVới ý tưởng về việc xây dựng một trang download tự động lấy các thông tin file và hiển thị lên giao diện cho người dùng cuối như đã trình bày trong mục Mô Hình Hoạt Động. Việc triển khai xây dựng giao diện dễ giao tiếp với máy chủ được thực hiện như sau:\nBlock giữ chỗ: \u0026lt;//nullSERVER?FILES?//\u0026gt;\nMáy chủ sẽ tìm block giữ chỗ này, sau đó thay thế block này bằng các template đã được xây dựng sẵn như bên dưới.\nMột block thông tin file khi được máy chủ chèn vào HTML có dạng như template sau:\n\u0026lt;div class=\u0026#34;content-box\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;file-icon\u0026#34; src= {đường dẫn đến icon dựa theo file ext}\u0026gt; \u0026lt;div class=\u0026#34;file-details\u0026#34;\u0026gt; \u0026lt;a href= {đường dẫn đến file}\u0026gt; {tên file} \u0026lt;/a\u0026gt; \u0026lt;h2\u0026gt;Size: {kích thước file} \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Trong đó, những thuộc tính {màu xanh} được server tự động thay đổi tuỳ theo từng tập tin. Với mỗi file được quét trong thư mục download, server sẽ thêm một template bên trên và điền các thông tin của file vừa quét vào, lặp lại công việc này với tất cả các file trong thư mục download ta sẽ có được danh sách những file có thể được người dùng cuối tải về.\nTrang đăng nhập gửi về server 3 trường dữ liệu là username, password và remember với phương thức POST. Các trường dữ liệu trong form đăng nhập là các trường bắt buộc nhập, nếu không có nội dung được nhập thì không thể submit các nội dung này gửi đến máy chủ.\nTruyền tải dữ liệu Transfer-Encoding: chunked được tận dụng tối đa thế mạnh nhờ bộ phận chia tài nguyên cần truy cập thành các bó tin nhỏ, tránh đọc dữ liệu hết cả file trong 1 lần để tiết kiệm tài nguyên hệ thống.\nĐối với các file HTML, CSS, JS được truy vấn để hiển thị cho người dùng cuối đều được truyền tải bằng phương thức thông thường (truyền cả file)\nSource Code Xem source code trên GitHub\n","date":"2020-12-28T23:05:15+07:00","image":"https://cngthnh.github.io/p/l%E1%BA%ADp-tr%C3%ACnh-socket-web-server-%C4%91%C6%A1n-gi%E1%BA%A3n/nullSERVER_hud5ef50abcd2b6d6a8e726228c1d6e7fb_16531_120x120_fill_box_smart1_2.png","permalink":"https://cngthnh.github.io/p/l%E1%BA%ADp-tr%C3%ACnh-socket-web-server-%C4%91%C6%A1n-gi%E1%BA%A3n/","title":"Lập trình Socket: Web Server đơn giản"},{"content":"Trình bày thuật toán Selection Sort Ý tưởng Với trường hợp sắp xếp mảng tăng dần có n phần tử, thuật toán Selection Sort (sắp xếp chọn) chia mảng thành 2 mảng con đã sắp xếp và chưa sắp xếp. Sau đó, tìm phần tử nhỏ nhất của mảng con chưa sắp xếp và di chuyển phần tử đó về cuối mảng con đã sắp xếp. Ban đầu chưa có phần tử nào được sắp xếp, phần tử được chọn để so sánh là phần tử đầu tiên của mảng, so sánh phần tử đó với phần tử nhỏ nhất trong n-1 phần tử còn lại, nếu phần tử được chọn lớn hơn phần tử nhỏ nhất của mảng con còn lại thì đổi chỗ 2 phần tử đó cho nhau. Tại mỗi vòng lặp, phần tử được chọn sẽ có vị trí tiến lên 1 đơn vị so với vòng lặp trước do sau mỗi vòng lặp sẽ có thêm 1 phần tử được di chuyển vào mảng con đã sắp xếp. Minh hoạ thuật toán void selectionSort(int* a, int n) { for (int i = 0; i \u0026lt; n - 1; i++) { int min = i; //phần tử thứ i là phần tử được chọn, phần tử này tạm thời là min  for (int j = i + 1; j \u0026lt; n; j++) if (a[j] \u0026lt; a[min]) min = j; //so sánh từng phần tử trong mảng con chưa sắp xếp với min hiện tại, nếu nhỏ hơn thì đó là min  swap(a[min], a[i]); //đổi chỗ min và phần tử được chọn  } }  Thay đổi của các phần tử trên mảng qua mỗi vòng lặp, phần tử có dấu * được đổi chỗ với phần tử đầu tiên trong mảng chưa sắp xếp (mảng màu xanh lá)  Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(n2)\n  Trung bình: O(n2)\n  Tốt nhất: O(n2)\n    Bộ nhớ sử dụng: O(1) do không sử dụng mảng phụ\n  Insertion Sort Ý tưởng Thuật toán Insertion Sort (sắp xếp chèn) duyệt từng phần tử và chèn phần tử đó vào mảng con (là mảng từ phần tử đầu tiên đến phần tử phía trước phần tử đã chọn) đã sắp xếp sao cho mảng đã sắp xếp đó vẫn giữ nguyên tính chất tăng hoặc giảm. Minh hoạ thuật toán void insertionSort(int* a, int n) { int i, j, key; for (i = 1; i \u0026lt; n; i++) //duyệt i từ 1 đến n, vì mảng con có 1 phần tử ở vị trí 0 luôn luôn đã được sắp xếp  { key = a[i]; //chọn phần tử thứ i để chèn vào mảng con gồm các phần tử đứng trước i  for (j = i - 1; j \u0026gt;= 0; j--) //duyệt mảng con đứng trước i (mảng này đã sắp xếp tăng hoặc giảm)  { if (a[j] \u0026lt;= key) break; //nếu a[j] \u0026lt;= key thì cần chèn key vào vị trí thứ j+1 để giữ nguyên tính chất của mảng con đứng trước i  a[j + 1] = a[j]; //nếu vẫn chưa tìm thấy vị trí cần chèn thì dời các phần tử lên 1 đơn vị để chừa chỗ chèn key  } a[j + 1] = key; chèn key vào vị trí j+1 } }  Thay đổi của các phần tử trên mảng qua mỗi vòng lặp, các phần tử được di chuyển theo hướng mũi tên  Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(n2)\n  Trung bình: O(n2)\n  Tốt nhất: O(n) - trong trường hợp mảng đã sắp xếp sẵn\n    Bộ nhớ sử dụng: O(1) do không sử dụng mảng phụ\n  Bubble Sort Ý tưởng Thuật toán Bubble Sort (sắp xếp nổi bột) lặp lại công việc đổi chỗ 2 số kế nhau nếu chúng đang đứng sai thứ tự cho đến khi mảng được sắp xếp. Trong mỗi chu trình nổi bọt, giá trị lớn nhất (hoặc nhỏ nhất) trong mảng chưa sắp xếp sẽ dần dần “nổi” lên trên, nhập vào mảng đã sắp xếp. Minh hoạ thuật toán Trong cài đặt Bubble Sort này, đã cải tiến bằng cách đặt 1 flag đánh dấu nếu không có sự hoán vị nào xảy ra (tức là mảng đã được sắp xếp và không cần chạy các vòng lặp còn lại nữa). void bubbleSort(int* a, int n) { bool isSwapped = 0; //flag đánh dấu mảng đã được sắp xếp hay chưa  for (int i = 0; i \u0026lt; n - 1; i++) { //phần tử cuối cùng luôn nằm đúng vị trí  isSwapped = 0; for (int j = 0; j \u0026lt; n - i - 1; j++) //duyệt các phần tử chưa được sắp xếp và đẩy phần tử lớn nhất (hoặc nhỏ nhất) lên cuối dãy  //duyệt j \u0026lt; n - i - 1 vì xét phần tử kế là j+1 = n - i =\u0026gt; không tràn sang mảng con đã sắp xếp ở cuối dãy  if (a[j] \u0026gt; a[j + 1]) { swap(a[j], a[j + 1]); //nếu 2 phần tử kế nhau nằm sai vị trí thì đổi chỗ  isSwapped = 1; } if (!isSwapped) return; //nếu đã sắp xếp thì dừng  } }  Đổi chỗ 2 ô màu xanh lá qua mỗi bước, những ô màu xám đã được sắp xếp, ô màu trắng chưa được sắp xếp  Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(n2)\n  Trung bình: O(n2)\n  Tốt nhất: O(n) - trong trường hợp mảng đã sắp xếp sẵn, vòng lặp chạy 1 lần rồi được gắn cờ đã sắp xếp và dừng hàm.\n    Bộ nhớ sử dụng: O(1) do không sử dụng mảng phụ\n  Merge Sort Ý tưởng Thuật toán Merge Sort (sắp xếp trộn) là một thuật toán chia để trị, thuật toán này sẽ chia mảng ra thành 2 mảng con, và tiếp tục công việc này với các mảng con đã chia cho tới khi nào những mảng con chỉ còn lại 1 phần tử, khi đó mỗi mảng con đều đã được sắp xếp do chỉ có 1 phần tử. Sau đó, thực hiện trộn các mảng con đã sắp xếp lại thành mảng con lớn hơn, lặp lại việc trộn mảng đến khi ta có mảng kết quả là toàn bộ các phần tử ban đầu đã được sắp xếp. Minh hoạ thuật toán void merge(int* a, int l, int m, int r) { /*đoạn này copy mảng con trái vào mảng L, mảng con phải vào mảng R; mảng con L có n1 phần tử, R có n2 phần tử*/ //thực hiện trộn 2 mảng L và R như sau:  for (int k = l; k \u0026lt;= r; k++) { if (i \u0026gt; n1-1) a[k] = R[j++]; // nếu đã hết phần tử trong mảng L thì chỉ cho những phần tử của mảng R vào mảng kết quả  else if (j \u0026gt; n2-1) a[k] = L[i++]; // nếu đã hết phần tử trong R thì cho những phần tử của L vào mảng kết quả  else if (L[i] \u0026gt; R[j]) a[k] = R[j++]; //nếu L[i]\u0026gt;R[j] thì cho R[j] vào mảng kết quả  else a[k] = L[i++]; //còn lại thì cho L[i] vào mảng kết quả (nếu L[i]==R[j] thì cho L[i] vào mảng, L luôn nằm bên trái R nên đảm bảo tính ổn định)  } } void mergeSort(int* a, int l, int r) { if (l \u0026gt;= r) return; int m = (l + r - 1) / 2; //phần tử giữa mảng  mergeSort(a, l, m); //gọi đệ quy mảng con từ m trở về bên trái  mergeSort(a, m + 1, r); //gọi đệ quy mảng con bên phải m  merge(a, l, m, r); //gộp 2 mảng con }  Màu tím là quá trình chia mảng thành các mảng con, màu xanh là quá trình trộn mảng, chia đến khi thành các mảng chỉ có 1 phần tử sau đó trộn các mảng đó lại  Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(nlog2n)\n  Trung bình: O(nlog2n)\n  Tốt nhất: O(nlog2n)\n    Bộ nhớ sử dụng: O(n) do phải sử dụng các mảng con tạm để lưu giá trị trước khi trộn chúng thành mảng kết quả\n  Quick Sort Ý tưởng Thuật toán Quick Sort là một thuật toán chia để trị với mấu chốt là thuật toán phân hoạch, chọn một phần tử trên mảng làm phần tử đánh dấu (pivot), sau đó di chuyển tất cả các phần tử nhỏ hơn pivot sang bên trái và các phần tử lớn hơn pivot sang bên phải. Lặp lại việc này với mỗi phân đoạn đã chia ta sẽ có được mảng đã sắp xếp Minh hoạ thuật toán Trong cài đặt này, sử dụng pivot ngẫu nhiên sẽ tránh được trường hợp xấu với mảng sắp xếp ngược void quickSort(int* a, int l, int r) { srand(time(NULL)); int key = a[l + rand() % (r - l + 1)]; int i = l, j = r; while (i \u0026lt;= j) //nếu đã duyệt hết mảng thì dừng vòng lặp  { while (a[i] \u0026lt; key) i++; //tìm phần tử bên trái lớn hơn pivot  while (a[j] \u0026gt; key) j--; //tìm phần tử bên phải nhỏ hơn pivot  if (i \u0026lt;= j) { //nếu i vẫn nằm bên trái pivot và j vẫn nằm bên phải pivot và phần tử a[i]\u0026gt;a[j] thì đổi chỗ 2 phần tử này  if (i \u0026lt; j) swap(a[i], a[j]); //đã xử lý xong 2 phần tử này, tăng i, giảm j để sang phần tử khác  i++; j--; } } //nếu l\u0026lt;j tức là mảng con bên trái còn nhiều hơn 1 phần tử, tiếp tục lặp lại thao tác cho mảng con bên trái  if (l \u0026lt; j) quickSort(a, l, j); //nếu i\u0026lt;r tức là mảng con bên phải còn nhiều hơn 1 phần tử, tiếp tục lặp lại thao tác cho mảng con bên phải  if (i \u0026lt; r) quickSort(a, i, r); }  Các phần tử khác màu tím là các phần tử được chọn làm pivot trong mỗi phân đoạn, các phân tử màu tím nhỏ hơn sẽ được di chuyển về bên trái pivot, lớn hơn sẽ di chuyển về bên phải pivot  Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(n2) - trong trường hợp pivot luôn bị random trúng phần tử lớn nhất (hoặc bé nhất)\n  Trung bình: O(nlog2n)\n  Tốt nhất: O(nlog2n)\n    Bộ nhớ sử dụng: O(nlog2n) trong trường hợp trung bình và O(n) trong trường hợp pivot luôn bị random trúng phần tử lớn nhất (hoặc bé nhất) khiến việc phân hoạch bị lệch thành 1 mảng con có 1 phần tử và mảng con còn lại có n-1 phần tử =\u0026gt; sử dụng n callstack\n  Heap Sort Ý tưởng Heap Sort có thể được xem là phiên bản cải tiến của Selection Sort với cơ chế tìm phần tử lớn nhất (hoặc nhỏ nhất) của mảng con chưa sắp xếp và di chuyển vào mảng con đã sắp xếp. Khác biệt nằm ở chỗ Heap Sort sử dụng cấu trúc heap để tìm phần tử lớn nhất (hoặc nhỏ nhất) thay vì tìm kiếm tuyến tính. Cấu trúc heap có thể biểu diễn ở dạng cây nhị phân cân bằng như bên dưới để dễ hình dung cách hoạt động của thuật toán này. Minh hoạ thuật toán void heapify(int* a, int n, int i) { //giá trị lớn nhất là giá trị tại nút đang xét  int largest = i; int l = 2 * i + 1; //vị trí nút con bên trái  int r = 2 * i + 2; //vị trí nút con bên phải  //nếu nút con bên trái lớn hơn nút đang xét thì gán nút con trái là lớn nhất  if (l \u0026lt; n \u0026amp;\u0026amp; a[l] \u0026gt; a[largest]) largest = l; //nếu nút con bên phải lớn hơn nút đang xét thì gán nút con phải là lớn nhất  if (r \u0026lt; n \u0026amp;\u0026amp; a[r] \u0026gt; a[largest]) largest = r; if (largest != i) { //nếu giá trị lớn nhất không phải là nút cha thì hoán đổi giá trị nút cha và nút con lớn nhất để nút cha trở thành lớn nhất và đệ quy với nút con vừa đổi giá trị để đảm bảo nút cha luôn lớn hơn nút con trên toàn bộ cây  swap(a[i], a[largest]); heapify(a, n, largest); } } void heapSort(int* a, int n) { //thực hiện tái cấu trúc mảng ban đầu thành heap (nút cha luôn lớn hơn nút con)  //các nút lớn hơn n/2-1 là các nút lá nên không cần xây dựng heap  for (int i = n / 2 - 1; i \u0026gt;= 0; i--) heapify(a, n, i); //vì nút cha là nút lớn nhất nên ta sẽ đổi giá trị ở nút cha và nút lá cuối cùng bên phải và ngắt nút lá đó ra khỏi cây  //nút lá đó chính là phần tử đã được sắp xếp  for (int i = n - 1; i \u0026gt; 0; i--) { swap(a[0], a[i]); heapify(a, i, 0); //thực hiện build heap lại với nút cha mới  } }  [Xây dựng heap - Đổi chỗ nút cha và nút lá cuối cùng bên phải - Ngắt nút lá] và lặp lại thao tác này cho tới khi nào mảng chỉ còn duy nhất một phần tử. Phần tử màu xanh lá cây trong hình trên là phần tử đã được sắp xếp  Đánh giá thuật toán   Độ phức tạp thời gian: Chiều cao của cây là nlog2n và mất n lần duyệt cây để có được mảng đã sắp xếp\n  Xấu nhất: O(nlog2n)\n  Trung bình: O(nlog2n)\n  Tốt nhất: O(nlog2n)\n    Bộ nhớ sử dụng: O(1) (không sử dụng mảng phụ)\n  Binary Insertion Sort Ý tưởng Binary Insertion Sort là phiên bản cải tiến của Insertion Sort, nó dùng thuật toán tìm kiếm nhị phân (chặt nhị phân - Binary Search) để tìm vị trí chèn phần tử ở mảng con chưa sắp xếp vào mảng con đã sắp xếp sao cho vẫn giữ nguyên tính chất tăng hoặc giảm. Minh hoạ thuật toán int binarySearch(int* a, int l, int r, int selected) { while (l \u0026lt; r) { int m = (l + r) / 2; if (a[m] == selected) { //nếu có nhiều phần tử trùng nhau thì chèn vào sau phần tử trùng cuối cùng =\u0026gt; Đảm bảo tính ổn định  while (a[++m] == selected); if (m \u0026gt; r) return r + 1; return m; } else if (a[m] \u0026lt; selected) l = m + 1; //nếu a[m] nhỏ hơn phần tử đã chọn thì vị trí chèn nằm bên phải m  else r = m - 1; //ngược lại thì vị trí chèn nằm bên trái m  } //nếu không có phần tử nào trong mảng con đã sắp xếp bằng với phần tử đã chọn thì xét tại a[l], nếu a[l] lớn hơn thì chèn vào trước a[l]  if (a[l] \u0026gt; selected) return l; //ngược lại thì chèn vào sau a[l]  return l+1; } void binaryInsertionSort(int* a, int n) { for (int i = 1; i \u0026lt; n; i++) { int selected = a[i]; int j = i - 1; int found = binarySearch(a, 0, j, selected); //dời các phần tử sau vị trí đã tìm sang bên phải 1 đơn vị để chừa chỗ chèn giá trị  while (j \u0026gt;= found) { a[j + 1] = a[j]; j--; } //chèn vào vị trí đã tìm  a[found] = selected; } } Hình ảnh trực quan minh hoạ cho sự dịch chuyển của các phần tử trong mảng tương tự như Hình 2 (phần Insertion Sort) Đánh giá thuật toán   Độ phức tạp thời gian:\n  Xấu nhất: O(n2)\n  Trung bình: O(n2)\n  Tốt nhất: O(nlog2n) - trong trường hợp mảng đã sắp xếp sẵn, mất log2n lần chặt nhị phân và n vòng lặp duyệt mảng\n    Bộ nhớ sử dụng: O(1) (không sử dụng mảng phụ)\n  Thực nghiệm Dữ liệu có thứ tự ngẫu nhiên  Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu thứ tự ngẫu nhiên  Nhận xét   Các thuật toán Merge Sort, Quick Sort, Heap Sort đều chạy rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất), trong đó Quick Sort nhanh hơn ở hầu hết các bài test.\n  Thuật toán Bubble Sort có thời gian chạy lâu nhất, gấp nhiều lần các thuật toán khác. Bubble Sort chậm hơn tất cả các thuật toán khác trong nhóm thuật toán sắp xếp chậm mặc dù được đánh giá cùng với độ phức tạp thời gian O(n2) do phải thực hiện phép hoán vị và duyệt lại mảng quá nhiều lần (dù đã cải tiến bằng cách thoát vòng lặp duyệt mảng nếu phát hiện mảng đã sắp xếp).\n  Insertion Sort và Binary Insertion Sort mất thời gian dưới 50s ở bài test có dữ liệu lớn nhất, trong đó Binary Insertion Sort nhanh hơn Insertion Sort khoảng 30% do cải tiến việc tìm vị trí bằng chặt nhị phân.\n  Dữ liệu đã được sắp xếp  Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu đã được sắp xếp  Nhận xét   Tất cả các thuật toán đều chạy rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất) với mảng đã được sắp xếp sẵn, trừ Selection Sort do cách tìm kiếm phần tử nhỏ nhất theo phương pháp tìm kiếm tuần tự nên phải duyệt lại mảng rất nhiều lần.\n  Insertion Sort chạy nhanh hơn hẳn so với khi sắp xếp mảng ngẫu nhiên do việc tìm vị trí bắt đầu từ ngay trước điểm đã chọn để chèn và vị trí cần chèn chính là chỗ cũ nên thời gian tìm vị trí và dời các phần tử là O(1), cộng thêm duyệt mảng mất O(n) nên tổng độ phức tạp thời gian của Insertion Sort ở bài test này chỉ là O(n).\n  Binary Insertion Sort ở bài test này chậm hơn so với Insertion Sort một chút, do phương pháp chặt nhị phân nên thời gian tìm kiếm vị trí mất O(log2n) thay vì O(1), thời gian dời các phần tử là O(1) do vị trí chèn chính là chỗ cũ, vậy nên tổng độ phức tạp thời gian của Binary Insertion Sort ở bài test này là O(nlog2n).\n  Bubble Sort chạy nhanh hơn hẳn so với mảng ngẫu nhiên do đã cải tiến, nếu duyệt qua mảng mà không có bất kì phép hoán vị nào tức là mảng đã sắp xếp và không cần sắp xếp nữa, ở bài test này độ phức tạp là O(n).\n  Các thuật toán Quick Sort, Merge Sort, Heap Sort vẫn rất nhanh, chênh lệch không lớn so với mảng ngẫu nhiên.\n  Dữ liệu đã sắp xếp ngược  Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu đã sắp xếp ngược  Nhận xét   Bubble Sort thể hiện rất tệ ở mảng sắp xếp ngược, do phải thực hiện O(n) phép hoán vị mới có thể làm phần tử lớn nhất “nổi bọt” đến cuối mảng\n  Insertion Sort và Binary Insertion Sort sắp xếp lâu gấp đôi so với mảng ngẫu nhiên, do với mỗi lần chèn phần tử đều phải dời toàn bộ mảng con đã sắp xếp để chèn phần tử vào (do mảng xếp ngược có phần tử đứng sau luôn bé hơn phần tử đứng trước). Binary Insertion Sort vẫn nhanh hơn Insertion Sort khoảng 30%\n  Selection Sort có thời gian chạy không thay đổi quá nhiều so với mảng ngẫu nhiên và mảng đã sắp xếp, do thuật toán này luôn phải duyệt lại mảng nhiều lần để tìm kiếm tuần tự phần tử min trong mảng chưa sắp xếp\n  Merge Sort, Quick Sort và Heap Sort vẫn rất nhanh (dưới 0.3s ở bài test có dữ liệu lớn nhất) và không chênh lệch nhau nhiều, Quick Sort nhanh hơn một chút so với hai thuật toán còn lại\n  Dữ liệu gần như đã sắp xếp  Biểu đồ thời gian chạy của các thuật toán sắp xếp với dữ liệu gần như đã sắp xếp  Nhận xét   Selection Sort vẫn giữ thời gian chạy giống như các mảng với thứ tự sắp xếp ngẫu nhiên, đã sắp xếp và sắp xếp ngược do tính chất của thuật toán.\n  Bubble Sort với mảng gần như sắp xếp chạy nhanh hơn Selection Sort và nhanh hơn khi sắp xếp các mảng ngẫu nhiên và sắp xếp ngược do chỉ có một vài phần tử bị xáo trộn, nên chỉ phải duyệt lại mảng k lần (với k là số phần tử nằm sai vị trí) và số lần hoán vị với mỗi vòng lặp nhỏ hơn hoặc bằng n (tuỳ thuộc vị trí của phần tử bị xáo trộn).\n  Các thuật toán còn lại đều sắp xếp rất nhanh (dưới 0.3s với bài test có dữ liệu lớn nhất). Trong đó Insertion Sort và Binary Insertion Sort là nhanh nhất do chỉ phải chèn k phần tử bị xáo trộn vào mảng đã sắp xếp.\n  Merge Sort, Quick Sort, Heap Sort sắp xếp mảng gần như đã sắp xếp với thời gian gần như tương tự các sắp xếp mảng khác.\n  Đánh giá tổng quan Đánh giá  Thuật toán Quick Sort nhanh hơn ở hầu hết các trường hợp (trừ mảng đã sắp xếp do đây là trường hợp đặc biệt của Bubble Sort, Insertion Sort và Binary Insertion Sort nên các thuật toán này chạy nhanh hơn). Bubble Sort chậm nhất ở hầu hết các trường hợp (trừ trường hợp mảng đã sắp xếp). Insertion Sort, Binary Insertion Sort, Bubble Sort sắp xếp chậm ở các mảng ngẫu nhiên, mảng xếp ngược. Nhưng lại nhanh hơn rõ rệt ở mảng đã sắp xếp hoặc gần như sắp xếp. Heap Sort và Merge Sort chậm hơn Quick Sort một chút nhưng lại ổn định về thời gian hơn QuickSort (không có trường hợp xấu O(n2). Merge Sort có nhược điểm là tốn bộ nhớ tạm để chứa các mảng con cần trộn. Selection Sort chậm đều nhau ở tất cả các thứ tự mảng do phải duyệt toàn bộ mảng con chưa sắp xếp để tìm phần tử nhỏ nhất, không có khác biệt trong tất cả các thứ tự mảng test. Tuỳ vào cách chọn pivot quyết định QuickSort nhanh hay chậm, ở đây sử dụng Randomized QuickSort nên không bị trường hợp xấu ở thứ tự mảng xếp ngược giống như khi chọn pivot ở cuối mảng. Các thuật toán Bubble Sort, Insertion Sort, Selection Sort, Binary Insertion Sort hiệu suất thấp nhưng cài đặt dễ dàng hơn so với Merge Sort, Quick Sort và Heap Sort.  Phân nhóm thuật toán theo độ ổn định Nhóm thuật toán sắp xếp ổn định (cần cài đặt cẩn thận để đảm bảo tính ổn định - chi tiết trong phần mô tả thuật toán)   Merge Sort\n  Binary Insertion Sort\n  Insertion Sort\n  Bubble Sort\n  Selection Sort\n  Nhóm thuật toán sắp xếp không ổn định   Heap Sort\n  Quick Sort\n  ","date":"2020-12-27T23:55:10+07:00","image":"https://cngthnh.github.io/p/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/sort_hu9dd4241d01f2a44c27ea4bac44362aa8_27425_120x120_fill_box_smart1_2.png","permalink":"https://cngthnh.github.io/p/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","title":"Thuật toán sắp xếp"}]